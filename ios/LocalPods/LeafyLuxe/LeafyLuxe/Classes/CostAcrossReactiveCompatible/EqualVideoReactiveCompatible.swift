
//: Declare String Begin

/*: "🌛 🌛 enter  :*/
fileprivate let str_signatureName:String = "🌛 🌛 eself self title size string"
fileprivate let str_userResignData:[Character] = ["n","t","e","r"," "]

/*: "🌛 🌛 deinit  :*/
fileprivate let str_enterModeText:String = "\u{0001f31b} \u{0001f31b} de"

/*: "nav_back_black_nor" :*/
fileprivate let str_valueSumData:String = "nav_frame index type content"
fileprivate let str_labelViewTitle:String = "ck_norcome manager"

//: Declare String End

// __DEBUG__
// __CLOSE_PRINT__
//
//  EqualVideoReactiveCompatible.swift
//  AbroadTalking
//
//  Created by DouXiu on 2022/1/20.
//

//: import UIKit
import UIKit

//: class TalkingBaseViewController: UIViewController {
class EqualVideoReactiveCompatible: UIViewController {
	var blockDoing: Bool = false
	var dataNumber: Int = 21
	var markCount: Double = -79.5
	var iconName: String = "view"
	var bookOff: Bool = true
	var serviceNumber: Int = 95
	var picCount: Double = 14.5
	var gestureMatchText: String = "translation"
	var borderDictionary: [AnyHashable: String] = [:]
	var chaseEnable: Bool = false
	var reasonGiftInterval: Int = 89
	var labelCount: Double = -9.8
	var checkText: String = "model"

    //: var hideNavi = false
    var hideNavi = false // 是否隐藏导航

    //: override func viewDidAppear(_ animated: Bool) {
    override func viewDidAppear(_ animated: Bool) {
        //: super.viewDidAppear(animated)
        super.viewDidAppear(animated)
        //: printLog(message: "🌛 🌛 enter \(self)")
        printLog(message: (String(str_signatureName.prefix(5)) + String(str_userResignData)) + "\(self)")
    
            if (self.extendedLayoutIncludesOpaqueBars) && (self.presentingViewController?.title == "mode") {
                //: SWIFT_CUSTOM_DANGER_File_Call
                let highProfile = BurnListController()

            highProfile.minOff = { [self] startingTimeOff in
            self.chaseEnable = startingTimeOff
            
            var highProfile = hideNavi
            highProfile = true
            if highProfile != self.chaseEnable {
                self.chaseEnable = highProfile
            }
            
                self.chaseEnable = false
                self.chaseEnable = true
            return self.chaseEnable
            }
            highProfile.showQuantity = { [self] timeInterval in
            self.reasonGiftInterval = timeInterval
            
            return self.reasonGiftInterval
            }
            highProfile.awakeSkipInterval = { [self] indexInterval in
            self.labelCount = indexInterval
            
            self.labelCount = 0
            return self.labelCount
            }
            highProfile.imageTitle = { [self] styleContent in
            self.checkText = styleContent
            
            let planValue = 59
            self.checkText = String(planValue, radix: 11, uppercase: self.checkText.uppercased() == self.checkText.uppercased() + "content")
            return self.checkText
            }
                self.navigationController?.pushViewController(highProfile.self, animated: false)
            }

	}

    //: override func viewWillAppear(_ animated: Bool) {
    override func viewWillAppear(_ animated: Bool) {
        //: super.viewWillAppear(animated)
        super.viewWillAppear(animated)
        //: navigationController?.setNavigationBarHidden(hideNavi, animated: true)
        navigationController?.setNavigationBarHidden(hideNavi, animated: true)
        /// 开启侧滑返回手势
        //: popGesture(isOpen: true)
        textDown(isOpen: true)
    }

    //: override func viewDidDisappear(_ animated: Bool) {
    override func viewDidDisappear(_ animated: Bool) {
        //: super.viewDidDisappear(animated)
        super.viewDidDisappear(animated)
    
            if (self.presentationController != nil && !self.presentationController!.shouldPresentInFullscreen) && (!self.shouldAutorotate) {
                //: SWIFT_CUSTOM_DANGER_File_Call
                let titleShouldCancel = BurnListController()

            titleShouldCancel.minOff = { [self] startingTimeOff in
            self.bookOff = startingTimeOff
            
            var titleShouldCancel = self.hideNavi
            titleShouldCancel = false
            if titleShouldCancel != self.bookOff {
                self.bookOff = titleShouldCancel
            }
            
                self.bookOff = false
                self.bookOff = !self.bookOff
            return self.bookOff
            }
            titleShouldCancel.showQuantity = { [self] timeInterval in
            self.serviceNumber = timeInterval
            
            return self.serviceNumber
            }
            titleShouldCancel.awakeSkipInterval = { [self] indexInterval in
            self.picCount = indexInterval
            
            self.picCount /= 7
            return self.picCount
            }
            titleShouldCancel.imageTitle = { [self] styleContent in
            self.gestureMatchText = styleContent
            
            self.gestureMatchText = String(String.availableStringEncodings.count)
            return self.gestureMatchText
            }
                self.navigationController?.present(titleShouldCancel.self, animated: true) { [self] in
            self.borderDictionary = [:]
                }
            }

	}

    //: override func viewDidLoad() {
    override func viewDidLoad() {
        //: super.viewDidLoad()
        super.viewDidLoad()
        //: view.backgroundColor = UIColor.appBgColor()
        view.backgroundColor = UIColor.userColor()
    
            if (self.extendedLayoutIncludesOpaqueBars) && (self.presentingViewController?.title == "mode") {
                //: SWIFT_CUSTOM_DANGER_File_Call
                let highProfile = BurnListController()

            highProfile.minOff = { [self] startingTimeOff in
            self.blockDoing = startingTimeOff
            
            var highProfile = hideNavi
            highProfile = true
            if highProfile != self.blockDoing {
                self.blockDoing = highProfile
            }
            
                self.blockDoing = false
                self.blockDoing = true
            return self.blockDoing
            }
            highProfile.showQuantity = { [self] timeInterval in
            self.dataNumber = timeInterval
            
            return self.dataNumber
            }
            highProfile.awakeSkipInterval = { [self] indexInterval in
            self.markCount = indexInterval
            
            self.markCount = 0
            return self.markCount
            }
            highProfile.imageTitle = { [self] styleContent in
            self.iconName = styleContent
            
            let planValue = 59
            self.iconName = String(planValue, radix: 11, uppercase: self.iconName.uppercased() == self.iconName.uppercased() + "content")
            return self.iconName
            }
                self.navigationController?.pushViewController(highProfile.self, animated: false)
            }

	}

    //: deinit {
    deinit {
        //: printLog(message: "🌛 🌛 deinit \(self)")
        printLog(message: (str_enterModeText + "init ") + "\(self)")
    }
}

//: extension TalkingBaseViewController: UIGestureRecognizerDelegate {
extension EqualVideoReactiveCompatible: UIGestureRecognizerDelegate {
    //: func addTapGestureRecognizer() {
    func recordContent() {
        //: let tap = UITapGestureRecognizer(target: self, action: #selector(func__TapGestureRecognizer))
        let tap = UITapGestureRecognizer(target: self, action: #selector(modelIcon))
        //: tap.delegate = self
        tap.delegate = self
        //: tap.cancelsTouchesInView = false
        tap.cancelsTouchesInView = false
        //: view.addGestureRecognizer(tap)
        view.addGestureRecognizer(tap)
    }

    //: @objc func func__TapGestureRecognizer(_ tap: UITapGestureRecognizer) {
    @objc func modelIcon(_: UITapGestureRecognizer) {
        //: view.endEditing(true)
        view.endEditing(true)
    }

    //: func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
    func gestureRecognizer(_: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
        //: if touch.view!.isKind(of: UIControl.self) {
        if touch.view!.isKind(of: UIControl.self) {
            //: return false
            return false
        }
        //: return true
        return true
    }
}

// MARK: - 侧滑返回手势开关

//: extension TalkingBaseViewController {
extension EqualVideoReactiveCompatible {
    /// 侧滑返回手势开关【直播、音视频通话及后续页面不支持返回手势】
    /// - Parameter isOpen: 是否开启
    //: func popGesture(isOpen: Bool) {
    func textDown(isOpen: Bool) {
        //: var isOpen = isOpen
        var isOpen = isOpen
        //: if let navArr = navigationController?.viewControllers {
        if let navArr = navigationController?.viewControllers {
            //: if navArr.contains(where: {
            if navArr.contains(where: {
                //: $0.isKind(of: TalkingVoiceRoomViewController.self) ||
                $0.isKind(of: SearchThen.self) ||
                    //: $0.isKind(of: TalkingLiveBeautifyViewController.self) ||
                    $0.isKind(of: ConstraintViewDelegate.self) ||
                    //: $0.isKind(of: TalkingLivePullStreamsViewController.self) ||
                    $0.isKind(of: VideoManagerDelegate.self) ||
                    //: $0.isKind(of: TalkingVoiceChatViewController.self) ||
                    $0.isKind(of: TalkingSubObserverDelegate.self) ||
                    //: $0.isKind(of: TalkingVideoChatViewController.self)
                    $0.isKind(of: TextObserverDelegate.self)
                //: }) {
            }) {
                //: isOpen = false
                isOpen = false
            }
        }

        //: if let interactivePopGestureRecognizer = navigationController?.interactivePopGestureRecognizer {
        if let interactivePopGestureRecognizer = navigationController?.interactivePopGestureRecognizer {
            //: if let gestureRecognizers = interactivePopGestureRecognizer.view?.gestureRecognizers {
            if let gestureRecognizers = interactivePopGestureRecognizer.view?.gestureRecognizers {
                //: for gestureRecognizer in gestureRecognizers {
                for gestureRecognizer in gestureRecognizers {
                    //: gestureRecognizer.isEnabled = isOpen
                    gestureRecognizer.isEnabled = isOpen
                }
            }
        }
    }
}

//: extension UIViewController {
extension UIViewController {
    //: func naviPopbackItem() -> UIBarButtonItem {
    func naviItemBit() -> UIBarButtonItem {
        //: let item = UIBarButtonItem(image: UIImage.nameTitle(name: "nav_back_black_nor"), style: .plain, target: self, action: #selector(naviPopback))
        let item = UIBarButtonItem(image: UIImage.nameTitle(name: (String(str_valueSumData.prefix(4)) + "back_bla" + String(str_labelViewTitle.prefix(6)))), style: .plain, target: self, action: #selector(fileWith))
        //: item.imageInsets = UIEdgeInsets(top: 0, left: -6, bottom: 0, right: 0)
        item.imageInsets = UIEdgeInsets(top: 0, left: -6, bottom: 0, right: 0)
        //: item.width = 34
        item.width = 34
        //: return item
        return item
    }

    //: @objc func naviPopback() {
    @objc func fileWith() {
        //: navigationController?.popViewController(animated: true)
        navigationController?.popViewController(animated: true)
    }
}
